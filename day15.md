# Day15 Async Cafe

## 왜 필요한가?
웹 브라우저는 멀티 스레드로 동작하기 어렵기 때문에 단일 스레드에서 이벤트 단위로 병렬 처리하는 구조로 동작한다. 스레드를 무한정 늘리지 않고 비동기 방식으로 동작하는 병렬 처리 방식에 대해 이해하고 구현할 수 있어야 한다.

## 학습 목표
- 카페에서 동시에 여러 고객이 다양한 음료를 주문했을 때 주문해서 나올 때까지 여러 명의 바리스타 비동기 작업을 시뮬레이션하는 프로그램을 만드는 것이 목표다. 
- 동기 방식 카페 시뮬레이터보다 효율적인 방식을 구현한다.

## 미션

- 지금까지 미션들에서 학습했던 다양한 패턴, 응용 방식을 활용해서 node 기반으로 작업한다.

- 다음 요구사항에 나오는 구성 요소들을 객체나 모듈로 구분해서 구현한다.

- 동기 함수들 보다 비동기 함수를 중심으로 구현한다.

### 1) 주문 이벤트 요구사항

- 스레드를 만드는 Worker 대신에, Node 기반 Event Emitter로 동작하는 비동기 이벤트 처리하도록 구현한다.

- 주문 담당자(Chashier)는 음료 주문을 연속해서 받을 수 있다.

- 음료 주문을 받으면 주문 대기표(Queue)에 추가한다.

  - 주문 대기표도 이벤트를 받아서 처리하는 별도 모듈/객체로 분리해서 구현한다.
  
- 매니저(Manager)는 음료를 확인하기 위해서 주문 대기표를 1초마다 확인한다. 

  - 주문이 있을 경우 작업이 비어있는 (제작할 수 있는) 바리스타에게 작업 이벤트를 전달한다.

- 바리스타(Barista)는 동시에 2개까지 음료를 만들 수 있다고 가정한다. 

  - Worker Thread가 아니라 이벤트 방식으로 동작해야 한다. 

  - 바리스타는 음료를 만들기 시작할 때와 끝날 때 마다 이벤트를 발생한다.

  - 이벤트가 발생할 때마다 음료 작업에 대한 로그를 출력한다.

- 매니저(Manager)는 바리스타가 보낸 특정 고객의 음료 제작 완료 이벤트를 받으면 현황판을 업데이트한다.

- 현황판(DashBoard)는 음료 주문 완성표를 주기적으로 화면에 출력한다.

  - 고객별로 음료수에 대해 대기중/제작중/완료 상태를 표시한다.

  - 현황판도 이벤트를 받아서 처리하는 별도 모듈/객체로 분리해서 구현한다.

- 아래 동작 예시는 이해를 돕기위한 예시일 뿐 동일하게 출력할 필요 없다. 각 요구사항을 확인하기 위해서 대기표, 현황판 등을 어떤 구조로 어떻게 구분해서 표시하는 게 적당한지 출력 형식을 고민한다.

#### 동작 예시

```
> 메뉴  =  1. 아메리카노(3s)    2. 카페라떼(5s)    3. 프라프치노(10s)
> 주문할 음료를 입력하세요. 예) 아메리카노 2개 => 1:2
> 1:2
/1,1/
아메리카노 시작
> 3:2
/1,3,3/
아메리카노 시작
> 2:3
/3,3,2,2/
아메리카노 완성
/3,2,2/
프라프치노 시작
아메리카노 완성
/2,2/
프라프치노 시작
..........
프라프치노 완성
프라프치노 완성
/2/
카페라떼 시작
//
카페라떼 시작
...
카페라떼 완성
카페라떼 완성
모든 메뉴가 완성되었습니다.

```

### 2) 주문 완료 요구사항

- 프로그램을 시작할 때 바리스타 인원수를 지정할 수 있도록 구현한다. 

  - 프로그램이 시작하면 바리스타가 몇 명인지 출력한다. 

  - 주문 담당자와 매니저는 각각 1명이라고 가정한다.

- 주문 담당자는 음료 주문을 받을 때마다 한꺼번에 주문한 고객을 구분해야 한다. 

- 매니저는 바리스타가 보낸 음료 작업 완료 이벤트를 받아서 고객별로 주문 완성표를 업데이트한다.

- 바리스타가 3명 이상일 경우 담당하는 음료수를 분배하는 방식을 구현한다. 모든 바리스타가 모든 음료수를 만들지 않아야 한다.

  - 바리스타 4명, 주문 고객 9명 + 음료 30개를 주문했다고 가정하고 동작을 확인한다.

- 현황판에는 주문한 고객별로 주문한 음료를 모두 구분해서 표시해야 한다.

  - 고객이 주문한 모든 음료가 완성되면 각자 자기만의 방식으로 특별하게(?) 표시해서 출력한다.
ㅈ
- 모든 음료수를 만들고 나서 3초 동안 주문이 없으면 프로그램을 종료한다.

- 주문부터 제작 완료까지 이벤트 흐름을 그림으로 그려서, PR 보낼 때와 피어 컴파일링 요청할 때 함께 첨부한다.

#### 동작 예시

```
> 바리스타는 총 2명입니다.
> 메뉴  =  1. 아메리카노(3s)    2. 카페라떼(5s)    3. 프라프치노(10s)
> 고객별로 주문할 음료 개수를 입력하세요. 예) A고객, 아메리카노 2개, 프라프치노 1개 => A, 1:2, 3:1
> A, 1:1, 2:1
/A1,A2/
바리스타1-A아메리카노 시작
/A2/
> B, 3:1, 2:1, 1:1
/A2,B3,B2,B1/
바리스타2-A카페라테 시작
/B3,B2,B1/
> C, 3:1, 1:1
/B3,B2,B1,C3,C1/
바리스타1-B프라프치노 시작
/B2,B1,C3,C1/
바리스타2-B카페라떼 시작
/B1,C3,C1/
바리스타1-A아메리카노 완성
.
바리스타1-B아메리카노 시작
/C3,C1/
바리스타2-A카페라떼 완성
===== A, 아메리카노, 카페라떼 주문 완성
.
바리스타2-C프라프치노 시작
/C1/
바리스타1-B아메리카노 완성
바리스타2-B카페라떼 완성
.
바리스타2-C아메리카노 시작
//
..
바리스타2-C아메리카노 완성
.......
바리스타1-B프라프치노 완성
===== B, 아메리카노, 카페라떼, 프라프치노 주문 완성
.
바리스타2-C프라프치노 완성
===== C, 아메리카노, 프라프치노 주문 완성
> 

모든 메뉴가 완성되었습니다.
```

### 3) Express 현황판

- 현황판(Dashboard)를 Node Express 기반으로 HTTP로 접근해서 확인할 수 있도록 한다.

- Express 패키지를 설치하고 9000 포트로 접속하면, `/` GET 요청을 받은 순간 현황판 상태를 JSON로 응답하도록 구현한다.

- `/${주문고객}` GET 요청을 받은 순간, 해당 주문 고객의 음료 주문 상태를 JSON로 응답하도록 구현한다.

## 배경 지식

### 비동기 병렬처리 

- 멀티 스레드 방식과 스레드에서 비동기 병렬 처리 방식에 대해 학습하고 정리한다.

- 동기 작업, 비동기 작업 처리 방식에 대해 비교하고 학습한다.

- 특정 스레드에서 이벤트 루프를 만들어서 각 이벤트를 전달하는 방식에 대해 학습한다.

- 비동기 작업을 동기화해서 기다리는 방식에 대해 학습한다.

- 비동기 작업을 그룹으로 묶어서 동기화하는 방식에 대해 학습한다.

## 학습정리

### 피어 컴파일링 체크포인트

```
  1. [ ] 바리스타 - 비동기 음료 제작 
  2. [ ] 음료 제작 - 비동기 이벤트 발생
  3. [ ] 매니저 - 주기적인 주문 확인
  4. [ ] 음료 주문 대기 큐 - 이벤트 처리
  5. [ ] 바리스타 인원 지정
  6. [ ] 고객별 여러 음료 주문 기능
  7. [ ] 고객별 주문 음료 현황판 출력
  8. [ ] 주문한 고객별로 전체 음료 완성 표시
  9. [ ] 바리스타 음료 제작 알고리즘 구현
  10. [ ] 이벤트 흐름에 대한 그림 설명
  11. [ ] Express 기반 현황판 전체 JSON 전송 구현
  12. [ ] Express 기반 고객별 JSON 전송 구현
```
  
### 스스로 확인할 사항

- Node.js 이벤트 루프와 이벤트 처리(Event Emitter) 방식에 대해 학습하고 정리한다.

- Day14에서 워커를 사용한 멀티 스레드 방식과 단일 스레드에서 비동기 병렬 처리 방식에 대해 비교해서 학습하고 정리한다.

### 다같이 확인할 사항

- Event-Bus 패턴에 대해 학습하고 주문 담당자, 매니저, 주문 대기표, 바리스타 관계를 비교한다. 

- Publish-subscribe 패턴에 대해 학습하고, 이벤트 처리 대신 구조에 적용할 수 있는지 확인한다.

- 만드는 데 4초가 걸리는 허브티와 15초가 걸리는 팥빙수를 추가하기 위한 구조와 코드를 토론한다.


